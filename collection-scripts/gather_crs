#!/bin/bash
source pwait
max_parallelism=10

# Forklift namespace passed in from main gather
backend_namespace=$1
user_namespace=$2

# Resource list
resources=()

# Dump forklift and kubevirt CRs
for component in forklift kubevirt; do
  for i in $(/usr/bin/oc get crd | grep ${component} | awk '{print $1}'); do
    resources+=($i)
  done

  echo "Starting collection of: [${resources[@]}]"

  # we use nested loops to nicely output objects partitioned per namespace, kind
  for resource in ${resources[@]}; do
    echo "Collecting CR ${resource}"

    if [ -z "${user_namespace}" ]; then
      objects=$(/usr/bin/oc get ${resource} --all-namespaces -o custom-columns=NAME:.metadata.name,NAMESPACE:.metadata.namespace --no-headers 2> /dev/null)
    else
      migtoolkit_cnv_objects=$(/usr/bin/oc get ${resource} -n ${backend_namespace} -o custom-columns=NAME:.metadata.name,NAMESPACE:.metadata.namespace --no-headers 2> /dev/null)
      vm_related_objects=$(/usr/bin/oc get ${resource} -n ${user_namespace} -o custom-columns=NAME:.metadata.name,NAMESPACE:.metadata.namespace --no-headers 2> /dev/null)
      objects="$(echo $migtoolkit_cnv_objects; echo $vm_related_objects)"
    fi

    echo "$objects" | \
    while read ocresource; do
      if [ -z "${ocresource}" ]; then
        continue
      fi
      ocobject=$(echo $ocresource | awk '{print $1}')
      ocproject=$(echo $ocresource | awk '{print $2}')
      if [ -z "${ocproject}" ]|[ "${ocproject}" == "<none>" ]; then
        object_collection_path=must-gather/cluster-scoped-resources/${resource}
        mkdir -p ${object_collection_path}
        /usr/bin/oc get ${resource} -o yaml ${ocobject} &> ${object_collection_path}/${ocobject}.yaml &
      else
        object_collection_path=must-gather/namespaces/${ocproject}/crs/${resource}
        mkdir -p ${object_collection_path}
        /usr/bin/oc get ${resource} -n ${ocproject} -o yaml ${ocobject} &> ${object_collection_path}/${ocobject}.yaml &
      fi
      pwait $max_parallelism
    done
  done
done

wait
